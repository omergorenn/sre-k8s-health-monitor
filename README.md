---

# **Health Monitor Project**

## **Overview**

This project is a **Kubernetes-native application** written in **Go**, designed to monitor the health of nodes and pods within a Kubernetes cluster.
The application integrates with **Prometheus** to collect metrics and uses **RabbitMQ** for alerting when resource thresholds are exceeded.

## **Tech Stack**

- **Golang**: Main programming language for the application.
- **Kubernetes**: Used to orchestrate the deployment and management of the application.
- **Prometheus**: For gathering and querying resource metrics (CPU, Memory) from nodes and pods.
- **RabbitMQ**: Used for queueing and dispatching alerts based on resource usage.
- **Helm**: For managing the deployment of various services like RabbitMQ, Prometheus, Fluent Bit, and Logstash.
- **Docker**: To containerize the application.
- **Minikube**: Local Kubernetes cluster used for development and testing.
- **Fluent Bit**: For log aggregation and forwarding.

## **Project Architecture**

The health monitor consists of the following main components:

1. **Node Reconciler**:
   - Monitors node resource usage (CPU and Memory) by querying Prometheus.
   - If thresholds are exceeded, an alert is sent to RabbitMQ.
   - Handles dynamic node IP retrieval for monitoring purposes.

2. **Pod Reconciler**:
   - Monitors pod lifecycle events and ensures that failing pods are restarted up to a retry limit.
   - Collects metrics on pod errors (e.g., CrashLoopBackOff) via Prometheus and sends alerts if necessary.

3. **RabbitMQ Integration**:
   - Alerts generated by the Node and Pod Reconcilers are sent to RabbitMQ queues for processing and notification.

4.Elasticsearch, Kibana, Logstash (ELK) Integration:
  Elasticsearch: Stores and indexes log data.
  Kibana: Provides a visual interface for querying and viewing logs.
  Logstash: Processes logs, forwarding them to Elasticsearch for indexing.
  Fluent Bit: Forwards logs from the Kubernetes nodes to Logstash for further processing.


---

## **Deployment Instructions**

### **Prerequisites**

Before deploying the application, ensure that the following services are installed and running in your Kubernetes cluster. Helm is used to manage these services.

### **Step 1: Installing Services via Helm**

1. **RabbitMQ Installation**:
   
   RabbitMQ is used as the message queue for sending alerts. Install RabbitMQ using Helm:

   ```bash
   helm install rabbitmq oci://registry-1.docker.io/bitnamicharts/rabbitmq --namespace monitoring
   ```

   **RabbitMQ Access**:

   ```bash
   # AMQP Port Forwarding
   kubectl port-forward --namespace monitoring svc/rabbitmq 5672:5672

   # Management Interface
   kubectl port-forward --namespace monitoring svc/rabbitmq 15672:15672
   ```

   - AMQP URL: `amqp://127.0.0.1:5672/`
   - Management Interface: `http://127.0.0.1:15672/`

2. **Prometheus Installation**:
   
   Prometheus collects cluster metrics. Install Prometheus using Helm:

   ```bash
   helm install prometheus prometheus-community/prometheus --namespace monitoring
   ```

3. **Fluent Bit Installation**:
   
   Fluent Bit forwards logs for observability. Install it using Helm:

   ```bash
   helm install fluentbit fluent/fluent-bit --namespace monitoring -f fluentbit-values.yaml
   ```

4. **Logstash Installation**:
   
   Logstash aggregates logs for processing:

   ```bash
   helm install logstash elastic/logstash --namespace monitoring
   ```

---

### **Step 2: Building and Deploying the Application**

1. **Build the Docker Image**:
   
   The application is containerized using Docker. Below is the Dockerfile used to build the application:

   ```dockerfile
   # Build stage
   FROM golang:1.23.1-alpine AS builder

   WORKDIR /app
   COPY . .

   RUN go mod download
   RUN CGO_ENABLED=0 GOOS=linux go build -o health-monitor /app/main.go

   # Final stage
   FROM alpine:latest
   WORKDIR /app

   COPY --from=builder /app/health-monitor /app/health-monitor
   COPY --from=builder /app/config /app/config

   CMD ["/app/health-monitor"]
   ```

   **Build the Docker image**:

   ```bash
   docker build -t health-monitor:latest .
   ```

   **Load the Docker image into Minikube**:

   ```bash
   minikube image load health-monitor:latest
   ```

2. **Deploy the Application to Kubernetes**:

   Create a Kubernetes deployment manifest (`deployment.yaml`) for the application:

   ```yaml
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: health-monitor
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: health-monitor
     template:
       metadata:
         labels:
           app: health-monitor
       spec:
         serviceAccountName: health-monitor-sa
         containers:
           - name: health-monitor
             image: health-monitor:latest
             imagePullPolicy: IfNotPresent

   ```

   **Apply the deployment**:

   ```bash
   kubectl apply -f deployment.yaml
   ```

---

### **Step 3: Configuring RBAC**

The application requires permissions to interact with Kubernetes resources like Pods and Nodes. Create an RBAC configuration:

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: health-monitor-sa

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: health-monitor-role
rules:
  - apiGroups: [""]
    resources: ["pods", "nodes"]
    verbs: ["get", "list", "watch", "delete", "update"]

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: health-monitor-rolebinding
subjects:
  - kind: ServiceAccount
    name: health-monitor-sa
    namespace: default
roleRef:
  kind: ClusterRole
  name: health-monitor-role
  apiGroup: rbac.authorization.k8s.io
```

Apply the RBAC configuration:

```bash
kubectl apply -f rbac.yaml
```

---

### **Step 4: Application Configuration**

The application uses **Viper** for managing its configurations. Configuration files for Prometheus and RabbitMQ are loaded via JSON files (`config.json` and `secret.json`).

Sample `config.json`:

```json
{
  "prometheus": {
    "host": "http://prometheus-service.default.svc.cluster.local",
    "port": "9090"
  },
  "rabbitMq": {
    "host": "rabbitmq-service.default.svc.cluster.local",
    "port": "5672"
  }
}
```

Sample `secret.json`:

```json
{
  "rabbitMqCredentials": {
    "user": "user",
    "password": "CNeTUvpl0DalJBvA"
  }
}
```


